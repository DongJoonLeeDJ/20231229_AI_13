//비트, 논리 연산
#include<stdio.h>
int main()
{
	//컴퓨터는 옛날에는 비트단위(0과 1)로 계산을 많이 했음
	//속도를 위해서 지금도 쓰이기도 함
	//그러나 요샌 비트단위보다는 간단한 사칙연산으로 계산하는 경우가 많음

	//비트 단위의 연산이므로 1과 0만 있음
	//여기서 1은 참, 0은 거짓을 의미함
	//좀 더 엄밀하게 말하면 0은 거짓, 0 이외의 수는 참이라고 봐도 됨

	// AND : & (shift 키 + 7)
	//하나라도 0(=거짓)이 있으면 전체를 거짓으로 봄
	int a = 7; //0111
	int b = 9; //1001
	printf("a & b = %d\n", a & b);
	// OR : |  (shift 키 + \)
	//하나라도 1(=참)이 있으면 전체를 참으로 봄
	printf("a | b = %d\n", a | b);

	// NOT : !(shift + 1)
	printf("!a = %d\n", !a); //a는 1은 아니지만 0도 아니므로 참
	//따라서 참의 반대는 거짓
	a = 0;
	printf("!a=%d\n", !a); //0(=거짓)의 반대는 참

	// XOR : ^(shift + 6)
	a = 8; //1000
	//8=1000
	//9=1001
	//XOR은 배타적 논리합, 이건 하나라도 다른 게 있어야 참(=1)
	//모두 다 똑같으면 거짓(00, 11에 대해서는 거짓=0)
	printf("a ^ b = %d\n", a ^ b); //1
	//shift 연산
	printf("%d %d\n", 8 << 2, 8 >> 2);//32, 2 


	//비트 연산 중 AND, OR, NOT, XOR 이런 것들을 이용해서
	//논리적인 계산을 세울 때 활용하기도 함
	//이러한 논리를 이용해서 특정한 명령을 특정한 상황에 수행하거나
	//특정한 횟수만큼 반복하게 하는 등의 명령을 수행할 수 있게 됨

	//부등호, 부호
	int c = 10; // = : 대입문
	//참 = 0이외의 모든 수를 의미함
	//== : 같은 여부 체크 -> 맞으면 1(=참), 틀리면 0(=거짓)
	//!= : 다른지 여부 체크 -> 맞으면 1(=참), 틀리면 0(=거짓)
	 
	// = 과 ==을 절대 헷갈리면 안 됨!
	//c==10 : c는 10이랑 같다 = 참 = 1
	//c != 11 : c는 11이랑 다르다 = 참 = 1
	// c>0 : c는 0보다 크다 = 참 = 1
	// c<100 : c는 100보다 작다 = 참 = 1
	// c<=100 : c는 100보다 작거나 혹은 100이랑 같다.(OR)  = 참 = 1
	// c>=0 : c는 0보다 크거나 혹은 0이랑 같다(OR)  = 참 = 1
	printf("%d %d %d %d %d %d\n", c == 10, c != 11, c > 0, c < 100, c<=100, c>=0);//전부 참
	printf("%d %d %d %d %d %d\n", c == 11, c != 10, c > 10, c < 10, c<=0, c>=100);//전부 거짓

	//
	printf("OR : %d\n", c > 0 || c == 0); //c는 10이므로 0보다 크다. 하나의 조건은 만족함
	printf("AND : %d\n", c > 0 && c < 100); //c는 0보다 크면서 100보다 작다. 즉 c는 1~99 중 하나
	printf("NOT : %d\n", !(c == 0)); //c가 0이랑 같다 = 거짓, 그것의 반대니까 참
	//XOR은 실무에서 비트계산이든 논리계산이든 보기가 매우 드물다.
	printf("XOR1 : %d\n", c > 0 ^ c == 0);  //1
	printf("XOR2 : %d\n", c > 0 ^ c < 100);  //0
	printf("XOR3 : %d\n", c<0 ^ c>100); //0 
	printf("XOR4 : %d\n", c<0 ^ c!=0); //1


	return 0;
}